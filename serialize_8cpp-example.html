<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>nytl - Modern C++ template library</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="http://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <a href="index.html" id="nytl">nytl 0.1.0</a>
				<a href="http://www.github.com/nyorain/nytl" id="githublink">github</a>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">serialize.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Example for serializing types and retrieving/setting typeNames.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serialize_8hpp.html">nytl/serialize.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//Serialized made classes</span></div><div class="line"><span class="keyword">class </span>BaseClass : <span class="keyword">public</span> nytl::Serialized&lt;BaseClass&gt; {};</div><div class="line"><span class="keyword">class </span>DerivedClass : <span class="keyword">public</span> nytl::DeriveSerialized&lt;BaseClass, DerivedClass&gt; {};</div><div class="line"></div><div class="line"><span class="comment">//DerivedTemplateClass</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class </span>DerivedTC : <span class="keyword">public</span> nytl::DeriveSerialized&lt;BaseClass, DerivedTC&lt;T&gt;&gt; {};</div><div class="line"></div><div class="line"><span class="comment">//To go the safe way and make it working across all platforms one must use a macro</span></div><div class="line">NYTL_GEN_TYPENAME(BaseClass)</div><div class="line">NYTL_GEN_TYPENAME(DerivedClass)</div><div class="line">NYTL_GEN_TEMPLATE_TYPENAME(DerivedTC)</div><div class="line"></div><div class="line"><span class="comment">//It will also work without this macro but only with certain non-standard extensions and not</span></div><div class="line"><span class="comment">//safely cross platform (the types will have the same name on EVERY platform).</span></div><div class="line"><span class="comment">//So prefer using this macro for all types and templates parameters of types that are serialized.</span></div><div class="line"><span class="comment">//Also specify it for int since we use it in the main function:</span></div><div class="line">NYTL_GEN_TYPENAME(<span class="keywordtype">int</span>)</div><div class="line"></div><div class="line"><span class="comment">//Alternatively, you can also give classes a name on creation by deriving from</span></div><div class="line"><span class="comment">//nytl::Named or nytl::DerivedNamed.</span></div><div class="line"><span class="keyword">class </span>StaticNamed : <span class="keyword">public</span> nytl::DeriveNamed&lt;BaseClass, TS(&quot;StaticNamed&quot;)&gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">//Create a Serializer (might also be done global)</span></div><div class="line">    <span class="comment">//See nytl::Serializer or nytl::Typemap for more information</span></div><div class="line">    nytl::DefaultSerializer serializer;</div><div class="line"></div><div class="line">    <span class="comment">//Add some random types to the typemap</span></div><div class="line">    <span class="comment">//notice how we dont have to specify their string identifier names here</span></div><div class="line">    <span class="comment">//we could also do that, then there would be no need for the macros used above to make</span></div><div class="line">    <span class="comment">//it work on all platforms.</span></div><div class="line">    nytl::addType&lt;DerivedClass&gt;(serializer);</div><div class="line">    nytl::addType&lt;DerivedTC&lt;int&gt;&gt;(serializer);</div><div class="line">    nytl::addType&lt;int&gt;(serializer);</div><div class="line"></div><div class="line">    <span class="comment">//dynamically create an object by typeName</span></div><div class="line">    <span class="keyword">auto</span> object1 = serializer.create(<span class="stringliteral">&quot;int&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> object2 = serializer.create(<span class="stringliteral">&quot;DerivedTC&lt;int&gt;&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">//check typeName</span></div><div class="line">    assert(nytl::any_cast&lt;DerivedTC&lt;int&gt;&gt;(object2).objectTypeName() == <span class="stringliteral">&quot;DerivedTC&lt;int&gt;&quot;</span>);</div><div class="line">    </div><div class="line">    std::cout &lt;&lt; object1.empty() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; object2.empty() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//output all registered types (names)</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; type : serializer.types())</div><div class="line">        std::cout &lt;&lt; type.first &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">//load object from stream</span></div><div class="line">    <span class="comment">//e.g. by int 43 which will dynamically (!) create a int with the value of 43 and</span></div><div class="line">    <span class="comment">//return it type-erased as an nytl::Any object.</span></div><div class="line">    <span class="comment">//Note that you can also use common base classes instead of nytl::Any for a nytl::Serializer</span></div><div class="line">    <span class="comment">//(or more general speaking a nytl::Typemap).</span></div><div class="line">    <span class="keywordflow">if</span>(!serializer.createLoad(std::cin).empty()) std::cout &lt;&lt; <span class="stringliteral">&quot;succesful\n&quot;</span>;</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">&quot;failed\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
		</div>
        <div id="footer-container">
            <div id="footer">
				nytl 0.1 Documentation, &copy; Jan Kelling 2015, published under <a href="https://github.com/nyorain/nytl/blob/master/LICENSE">MIT License</a><br />
				Documentation generated by <a href="http://www.stack.nl/~dimitri/doxygen/">doxygen</a>
            </div>
        </div>
    </body>
</html>
