<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.10"/>
		<title>nytl documentation page</title>
        <script type="text/javascript" src="dynsections.js"></script>
		<script src="jquery/jquery.min.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link rel="stylesheet" href="bootstrap/css/bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="bootstrap/doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-inverse" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a href="index.html" class="navbar-brand"> nytl </a>
                </div>
				  <ul class="nav navbar-nav collapse navbar-collapse">
					<li><a href="https://github.com/nyorain/nytl"> github </a></li>
<!--
					<li class="dropdown">
					  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Pages <span class="caret"></span></a>
					  <ul class="dropdown-menu">
						<li><a href="#">Action</a></li>
						<li><a href="#">Another action</a></li>
						<li><a href="#">Something else here</a></li>
						<li role="separator" class="divider"></li>
						<li><a href="#">Separated link</a></li>
						<li role="separator" class="divider"></li>
						<li><a href="#">One more separated link</a></li>
					  </ul>
					</li>
!-->
				  </ul>
            </div>
        </nav>
        <div id="top">
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;"><!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nytl</b></li><li class="navelem"><a class="el" href="classnytl_1_1simplex.html">simplex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classnytl_1_1simplex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nytl::simplex&lt; D, P, A, typename &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::size_t D, typename P = float, std::size_t A = D, typename = DimMatch&lt;D, A&gt;&gt;<br />
class nytl::simplex&lt; D, P, A, typename &gt;</h3>

<p>The simplex&lt;D, P, A&gt; template class defines an unique area with  dimensions of  precision in an  dimensional space. So e.g. simplex&lt;3, float, 2&gt; describes a triangle in a 3-dimensional space. This template class does only works if D &gt;= A, since the dimension of the area can not be higher than the dimension of the space that contains this area. The area is called unique, since it does have a variable number of points defining it; always enough to describe exactly one, unambigous area with the given dimension and precision in the given space. </p>
</div>
<p><code>#include &lt;<a class="el" href="simplex_8hpp_source.html">simplex.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2eb9af9c9ec37273715876a64f3fe374"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2eb9af9c9ec37273715876a64f3fe374"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec_type</b> = <a class="el" href="classnytl_1_1vec.html">vec</a>&lt; D, P &gt;</td></tr>
<tr class="separator:a2eb9af9c9ec37273715876a64f3fe374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa7bc15aa66cd23a510590355f030e761"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7bc15aa66cd23a510590355f030e761"></a>
template&lt;typename... Args, typename  = typename std::enable_if&lt;			std::is_convertible&lt;				std::tuple&lt;Args...&gt;,				type_tuple_t&lt;vec_type, A + 1&gt;			&gt;::value		&gt;::type&gt; </td></tr>
<tr class="memitem:aa7bc15aa66cd23a510590355f030e761"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simplex</b> (Args &amp;&amp;...args) noexcept</td></tr>
<tr class="separator:aa7bc15aa66cd23a510590355f030e761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc54063e2107e5a0e1fd5a7c86c8139"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fc54063e2107e5a0e1fd5a7c86c8139"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a8fc54063e2107e5a0e1fd5a7c86c8139">size</a> () const </td></tr>
<tr class="memdesc:a8fc54063e2107e5a0e1fd5a7c86c8139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the area (e.g. for a 3-dimensional area this would be the volume) <br /></td></tr>
<tr class="separator:a8fc54063e2107e5a0e1fd5a7c86c8139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46fe3f6afe54b36c426d2d4151bc7e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad46fe3f6afe54b36c426d2d4151bc7e5"></a>
<a class="el" href="classnytl_1_1vec.html">vec_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#ad46fe3f6afe54b36c426d2d4151bc7e5">center</a> () const </td></tr>
<tr class="memdesc:ad46fe3f6afe54b36c426d2d4151bc7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the center point of the area. <br /></td></tr>
<tr class="separator:ad46fe3f6afe54b36c426d2d4151bc7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185e1d5f4b13c4a90f7de645813d634d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a185e1d5f4b13c4a90f7de645813d634d">sameSpace</a> (const <a class="el" href="classnytl_1_1vec.html">vec_type</a> &amp;val) const </td></tr>
<tr class="separator:a185e1d5f4b13c4a90f7de645813d634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf711aa45aa80b08f91cb049e254058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnytl_1_1vec.html">vec</a>&lt; A+1, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a3bf711aa45aa80b08f91cb049e254058">barycentric</a> (const <a class="el" href="classnytl_1_1vec.html">vec_type</a> &amp;val) const </td></tr>
<tr class="separator:a3bf711aa45aa80b08f91cb049e254058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9321a96e02b41c0438d86636584a1d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnytl_1_1vec.html">vec</a>&lt; A+1, <a class="el" href="classnytl_1_1vec.html">vec_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a9321a96e02b41c0438d86636584a1d2b">asVec</a> ()</td></tr>
<tr class="separator:a9321a96e02b41c0438d86636584a1d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa506282b356c702f863a63d94c803b8b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnytl_1_1vec.html">vec</a>&lt; A+1, <a class="el" href="classnytl_1_1vec.html">vec_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#aa506282b356c702f863a63d94c803b8b">asVec</a> () const </td></tr>
<tr class="separator:aa506282b356c702f863a63d94c803b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4605dbb19fa715b9728cd55739c931c"><td class="memTemplParams" colspan="2">template&lt;std::size_t OD, typename OP &gt; </td></tr>
<tr class="memitem:af4605dbb19fa715b9728cd55739c931c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#af4605dbb19fa715b9728cd55739c931c">operator simplex&lt; OD, OP, A &gt;</a> () const </td></tr>
<tr class="separator:af4605dbb19fa715b9728cd55739c931c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4605dbb19fa715b9728cd55739c931c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af4605dbb19fa715b9728cd55739c931c"></a>
template&lt;std::size_t OD, typename OP &gt; </td></tr>
<tr class="memitem:af4605dbb19fa715b9728cd55739c931c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator simplex&lt; OD, OP, A &gt;</b> () const </td></tr>
<tr class="separator:af4605dbb19fa715b9728cd55739c931c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3d55e7d27c3917d678e7e625cbf043dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d55e7d27c3917d678e7e625cbf043dc"></a>
<a class="el" href="classnytl_1_1vec.html">vec</a>&lt; A+1, <a class="el" href="classnytl_1_1vec.html">vec_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a3d55e7d27c3917d678e7e625cbf043dc">points</a></td></tr>
<tr class="memdesc:a3d55e7d27c3917d678e7e625cbf043dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the points that define the area. <br /></td></tr>
<tr class="separator:a3d55e7d27c3917d678e7e625cbf043dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad5d388bed363a515a59b3ea8d974d7b9"><td class="memTemplParams" colspan="2">template&lt;std::size_t D, typename P , std::size_t A&gt; </td></tr>
<tr class="memitem:ad5d388bed363a515a59b3ea8d974d7b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#ad5d388bed363a515a59b3ea8d974d7b9">contains</a> (const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;s, const <a class="el" href="classnytl_1_1vec.html">vec</a>&lt; D, P &gt; &amp;v)</td></tr>
<tr class="separator:ad5d388bed363a515a59b3ea8d974d7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5885a9493316f2da1e733a37c5d23c"><td class="memTemplParams" colspan="2">template&lt;std::size_t D, typename P , std::size_t A&gt; </td></tr>
<tr class="memitem:a1e5885a9493316f2da1e733a37c5d23c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a1e5885a9493316f2da1e733a37c5d23c">intersects</a> (const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;s1, const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;s2)</td></tr>
<tr class="separator:a1e5885a9493316f2da1e733a37c5d23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afd6dc96016f2c0dddf33086a0e41d4"><td class="memTemplParams" colspan="2">template&lt;std::size_t D, typename P , std::size_t A&gt; </td></tr>
<tr class="memitem:a4afd6dc96016f2c0dddf33086a0e41d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a4afd6dc96016f2c0dddf33086a0e41d4">contains</a> (const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;s1, const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;s2)</td></tr>
<tr class="separator:a4afd6dc96016f2c0dddf33086a0e41d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1deee488de23d977bbb88d33e6904fa"><td class="memTemplParams" colspan="2">template&lt;std::size_t D, typename P , std::size_t A&gt; </td></tr>
<tr class="memitem:ab1deee488de23d977bbb88d33e6904fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>&lt; D, P, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#ab1deee488de23d977bbb88d33e6904fa">intersection</a> (const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;, const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;)</td></tr>
<tr class="separator:ab1deee488de23d977bbb88d33e6904fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb593ec05696c0468ef2c95a6a415df6"><td class="memTemplParams" colspan="2">template&lt;std::size_t D, typename P , std::size_t A&gt; </td></tr>
<tr class="memitem:abb593ec05696c0468ef2c95a6a415df6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>&lt; D, P, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#abb593ec05696c0468ef2c95a6a415df6">combination</a> (const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;, const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;)</td></tr>
<tr class="separator:abb593ec05696c0468ef2c95a6a415df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340fe94010800975ed92fdd20020a3b1"><td class="memTemplParams" colspan="2">template&lt;std::size_t D, typename P , std::size_t A&gt; </td></tr>
<tr class="memitem:a340fe94010800975ed92fdd20020a3b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>&lt; D, P, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a340fe94010800975ed92fdd20020a3b1">symmetricDifference</a> (const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;, const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;)</td></tr>
<tr class="separator:a340fe94010800975ed92fdd20020a3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a3475f0eb6cc31183beeba8f3d63ca"><td class="memTemplParams" colspan="2">template&lt;std::size_t D, typename P , std::size_t A&gt; </td></tr>
<tr class="memitem:a46a3475f0eb6cc31183beeba8f3d63ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>&lt; D, P, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnytl_1_1simplex.html#a46a3475f0eb6cc31183beeba8f3d63ca">difference</a> (const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;, const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;)</td></tr>
<tr class="separator:a46a3475f0eb6cc31183beeba8f3d63ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9321a96e02b41c0438d86636584a1d2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P  = float, std::size_t A = D, typename  = DimMatch&lt;D, A&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnytl_1_1vec.html">vec</a>&lt;A + 1, <a class="el" href="classnytl_1_1vec.html">vec_type</a>&gt;&amp; <a class="el" href="classnytl_1_1simplex.html">nytl::simplex</a>&lt; D, P, A, typename &gt;::asVec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the object into a vec of points. Can be used to acces (read/change/manipulate) the points. </p>

</div>
</div>
<a class="anchor" id="aa506282b356c702f863a63d94c803b8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P  = float, std::size_t A = D, typename  = DimMatch&lt;D, A&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnytl_1_1vec.html">vec</a>&lt;A + 1, <a class="el" href="classnytl_1_1vec.html">vec_type</a>&gt;&amp; <a class="el" href="classnytl_1_1simplex.html">nytl::simplex</a>&lt; D, P, A, typename &gt;::asVec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the object into a const vec of poitns. Can be used to const_iterate/read the points. </p>

</div>
</div>
<a class="anchor" id="a3bf711aa45aa80b08f91cb049e254058"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P  = float, std::size_t A = D, typename  = DimMatch&lt;D, A&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnytl_1_1vec.html">vec</a>&lt; A+1, double &gt; simplex::barycentric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1vec.html">vec_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the given normal coordinates into barycentric coordinates for the simplex object. If the given point does not lay in the same space as the simplex object, the function will output a warning and return a null-vector. This can be checked before with <a class="el" href="classnytl_1_1simplex.html#a185e1d5f4b13c4a90f7de645813d634d">sameSpace()</a>. </p>

</div>
</div>
<a class="anchor" id="af4605dbb19fa715b9728cd55739c931c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P  = float, std::size_t A = D, typename  = DimMatch&lt;D, A&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::size_t OD, typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnytl_1_1simplex.html">nytl::simplex</a>&lt; D, P, A, typename &gt;::operator <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; OD, OP, A &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the object to a simplex with a different dimension or precision. Note that the area dimension A cannot be changed, only the space dimension D. Works only if the new D is still greater equal A. </p>

</div>
</div>
<a class="anchor" id="a185e1d5f4b13c4a90f7de645813d634d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P  = float, std::size_t A = D, typename  = DimMatch&lt;D, A&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool simplex::sameSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1vec.html">vec_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the simplex lays in the same space as the given point. If e.g. D==2 it checks whether they lay on the same plane. If D==A this will always return true. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="abb593ec05696c0468ef2c95a6a415df6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P , std::size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>&lt; D, P, A &gt; combination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Combines the first and the second area (Offically called union but this name is not available in c++). Result is not guaranteed to be representable by one single simplex and is therefore a <a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>. Symmetrical operator. [OR] </p>

</div>
</div>
<a class="anchor" id="ad5d388bed363a515a59b3ea8d974d7b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P , std::size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1vec.html">vec</a>&lt; D, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests if the given simplex contains the given point. </p>

</div>
</div>
<a class="anchor" id="a4afd6dc96016f2c0dddf33086a0e41d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P , std::size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests if the first simplex fully contains the second one. Asymmetrical operator. </p>

</div>
</div>
<a class="anchor" id="a46a3475f0eb6cc31183beeba8f3d63ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P , std::size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>&lt; D, P, A &gt; difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the second area from the first one and returns the "rest" of the first area. Return type is a <a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a> since the result is not guaranteed to be representable by one single simplex. Asymmetrical operator. [AND NOT] </p>

</div>
</div>
<a class="anchor" id="ab1deee488de23d977bbb88d33e6904fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P , std::size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>&lt; D, P, A &gt; intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the region of intersection between the two given simplexs. Result is not guaranteed to be representable by a simplex and therefore a <a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a> (i.e. the intersection of two triangles is not guaranteed to be a triangle). Symmetrical operator. [AND] </p>

</div>
</div>
<a class="anchor" id="a1e5885a9493316f2da1e733a37c5d23c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P , std::size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests two simplexs for intersection. Symmetrical operator. </p>

</div>
</div>
<a class="anchor" id="a340fe94010800975ed92fdd20020a3b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename P , std::size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnytl_1_1simplexRegion.html">simplexRegion</a>&lt; D, P, A &gt; symmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnytl_1_1simplex.html">simplex</a>&lt; D, P, A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the symmetric difference of the two given simplexs, so basically the region in the given space where exactly one of the two given areas are located. Symmetrical operator. [XOR] </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="simplex_8hpp_source.html">simplex.hpp</a></li>
<li>simplex.inl</li>
</ul>
</div><!-- contents -->
        </div>
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
<center>
	nytl 0.1 Documentation, &copy; Jan Kelling 2015, published under <a href="https://github.com/nyorain/nytl/blob/master/LICENSE">MIT License</a><br />
	Documentation generated by <a href="http://www.stack.nl/~dimitri/doxygen/">doxygen</a>, styled with <a href="http://getbootstrap.com/2.3.2/">bootstrap</a>
</center>
<br />
</body>
</html>