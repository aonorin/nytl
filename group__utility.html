<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>nytl - Modern C++ template library</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="http://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <a href="index.html" id="nytl">nytl 0.1.0</a>
				<a href="http://www.github.com/nyorain/nytl" id="githublink">github</a>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility</div>  </div>
</div><!--header-->
<div class="contents">

<p>General utility base classes as well as smart pointers and helpers for serializing types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1RecursiveIterator.html">nytl::RecursiveIterator&lt; T, I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for recursively iterate over a object with multiple sub-iterators.  <a href="classnytl_1_1RecursiveIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1RecursiveIteration.html">nytl::RecursiveIteration&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows recursive iteration (like range-based for loop) over an object with sub-iterators.  <a href="classnytl_1_1RecursiveIteration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1Cloneable.html">nytl::Cloneable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a> base class.  <a href="classnytl_1_1Cloneable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1AbstractCloneable.html">nytl::AbstractCloneable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract <a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a> base class.  <a href="classnytl_1_1AbstractCloneable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1DeriveCloneable.html">nytl::DeriveCloneable&lt; Base, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility template to derive from a class with a virtual clone function.  <a href="classnytl_1_1DeriveCloneable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1HierachyBase.html">nytl::HierachyBase&lt; Root, Child &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual utility base template class for objects that are part of a Hierachy.  <a href="classnytl_1_1HierachyBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1Observer.html">nytl::Observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for classes that observe the lifetime of other Observeable objects.  <a href="classnytl_1_1Observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1Observable.html">nytl::Observable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to make the objects lifetime observable.  <a href="classnytl_1_1Observable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1ObservingPtr.html">nytl::ObservingPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer class that observes the lifetime of its object.  <a href="classnytl_1_1ObservingPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1Referenced.html">nytl::Referenced</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference counted objects.  <a href="classnytl_1_1Referenced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1IntrusivePtr.html">nytl::IntrusivePtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer class for objects with built-in reference counter.  <a href="classnytl_1_1IntrusivePtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1TimeDuration.html">nytl::TimeDuration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dervied from the std duration class but offers more operations and built-in conversions.  <a href="classnytl_1_1TimeDuration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1TimePoint.html">nytl::TimePoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dervied from the std time_point class but offers more operations and built-in conversions.  <a href="classnytl_1_1TimePoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1Timer.html">nytl::Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers functionality to track the elapsed time since a set time point.  <a href="classnytl_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnytl_1_1Typemap.html">nytl::Typemap&lt; I, B, CArgs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be thought of as map (like std::map) that holds pair of identifiers and types.  <a href="classnytl_1_1Typemap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga48a0a0b29a3d4cc37a7a285dc25e36af"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ga48a0a0b29a3d4cc37a7a285dc25e36af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga48a0a0b29a3d4cc37a7a285dc25e36af">nytl::void_t</a> = void</td></tr>
<tr class="memdesc:ga48a0a0b29a3d4cc37a7a285dc25e36af"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++17 alias template for void, used to detect ill-formad types in a SFINAE-context.  <a href="group__utility.html#ga48a0a0b29a3d4cc37a7a285dc25e36af">More...</a><br /></td></tr>
<tr class="separator:ga48a0a0b29a3d4cc37a7a285dc25e36af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ada50e83b7cfcab8133fdaf7c8e477"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21ada50e83b7cfcab8133fdaf7c8e477"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga21ada50e83b7cfcab8133fdaf7c8e477">nytl::raw</a> = typename detail::rawT&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga21ada50e83b7cfcab8133fdaf7c8e477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta programming template to remove all qualifiers and references from a given type T.  <a href="group__utility.html#ga21ada50e83b7cfcab8133fdaf7c8e477">More...</a><br /></td></tr>
<tr class="separator:ga21ada50e83b7cfcab8133fdaf7c8e477"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7db0db5ea24e292ebfa55613d95a45c7"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:ga7db0db5ea24e292ebfa55613d95a45c7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; decltype(clone(A{}))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga7db0db5ea24e292ebfa55613d95a45c7">nytl::cloneVector</a> (const std::vector&lt; A &gt; &amp;VectorObject)</td></tr>
<tr class="memdesc:ga7db0db5ea24e292ebfa55613d95a45c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to copy a Vector of <a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a> objects by cloning.  <a href="group__utility.html#ga7db0db5ea24e292ebfa55613d95a45c7">More...</a><br /></td></tr>
<tr class="separator:ga7db0db5ea24e292ebfa55613d95a45c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a79056e1d1df00484f0f6833856110"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:gae9a79056e1d1df00484f0f6833856110"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gae9a79056e1d1df00484f0f6833856110">nytl::unused</a> (T &amp;&amp;...)</td></tr>
<tr class="memdesc:gae9a79056e1d1df00484f0f6833856110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility template function that can be used to hide unused compiler warnings.  <a href="group__utility.html#gae9a79056e1d1df00484f0f6833856110">More...</a><br /></td></tr>
<tr class="separator:gae9a79056e1d1df00484f0f6833856110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acfa7ed9dd857e72bb57096b541b15d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ga3acfa7ed9dd857e72bb57096b541b15d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga3acfa7ed9dd857e72bb57096b541b15d">nytl::printVars</a> (std::ostream &amp;out, Args...args)</td></tr>
<tr class="memdesc:ga3acfa7ed9dd857e72bb57096b541b15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the given args to the given output stream.  <a href="group__utility.html#ga3acfa7ed9dd857e72bb57096b541b15d">More...</a><br /></td></tr>
<tr class="separator:ga3acfa7ed9dd857e72bb57096b541b15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e9ee1dad8ebb7288a3535111a97bad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92e9ee1dad8ebb7288a3535111a97bad"></a>
std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nytl::split</b> (const std::string &amp;s, char delim, std::vector&lt; std::string &gt; &amp;elems)</td></tr>
<tr class="separator:ga92e9ee1dad8ebb7288a3535111a97bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7dd5357214633d474ab1fff04706463"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac7dd5357214633d474ab1fff04706463"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nytl::split</b> (const std::string &amp;s, char delim)</td></tr>
<tr class="separator:gac7dd5357214633d474ab1fff04706463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abfac9087e28a3a3ee48507fc28bfbf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4abfac9087e28a3a3ee48507fc28bfbf"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga4abfac9087e28a3a3ee48507fc28bfbf">nytl::dumpContainer</a> (const T &amp;obj, const char *sep=&quot;,\n&quot;)</td></tr>
<tr class="memdesc:ga4abfac9087e28a3a3ee48507fc28bfbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a given iteratable container to a stringstream and returns its content.  <a href="group__utility.html#ga4abfac9087e28a3a3ee48507fc28bfbf">More...</a><br /></td></tr>
<tr class="separator:ga4abfac9087e28a3a3ee48507fc28bfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f089bded3dfc2a5b9b525c7625e73c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3f089bded3dfc2a5b9b525c7625e73c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3f089bded3dfc2a5b9b525c7625e73c9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nytl::typeName</b> (bool space=0)</td></tr>
<tr class="separator:ga3f089bded3dfc2a5b9b525c7625e73c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb74c2145748be1c94d2a0d8f76fe3c"><td class="memTemplParams" colspan="2"><a class="anchor" id="gafeb74c2145748be1c94d2a0d8f76fe3c"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gafeb74c2145748be1c94d2a0d8f76fe3c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nytl::typeNames</b> (bool space=0)</td></tr>
<tr class="separator:gafeb74c2145748be1c94d2a0d8f76fe3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f1c4cd979d8afa4767c3bb05a26959"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga73f1c4cd979d8afa4767c3bb05a26959"></a>
template&lt;typename T , typename Base , typename... CArgs&gt; </td></tr>
<tr class="memitem:ga73f1c4cd979d8afa4767c3bb05a26959"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nytl::addType</b> (Serializer&lt; Base, CArgs... &gt; &amp;m)</td></tr>
<tr class="separator:ga73f1c4cd979d8afa4767c3bb05a26959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga440bf24bb3f0e5f22578fad32167906d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga440bf24bb3f0e5f22578fad32167906d"></a>
constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>nytl::osName</b> ()</td></tr>
<tr class="separator:ga440bf24bb3f0e5f22578fad32167906d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41085d074baa3e6509b860a4d125fd3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41085d074baa3e6509b860a4d125fd3e"></a>
constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>nytl::compilerName</b> ()</td></tr>
<tr class="separator:ga41085d074baa3e6509b860a4d125fd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a690745f85b8d0ab553ca287d6b969"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8a690745f85b8d0ab553ca287d6b969"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>nytl::is64Bit</b> ()</td></tr>
<tr class="separator:gaa8a690745f85b8d0ab553ca287d6b969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6532883143d1496fc7b1032d72d7f11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac6532883143d1496fc7b1032d72d7f11"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nytl::littleEndian</b> ()</td></tr>
<tr class="separator:gac6532883143d1496fc7b1032d72d7f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69f8680486de294672d6cc063ca6247d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69f8680486de294672d6cc063ca6247d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nytl::bigEndian</b> ()</td></tr>
<tr class="separator:ga69f8680486de294672d6cc063ca6247d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8eaf71cbc38948db216ab785646636"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4f8eaf71cbc38948db216ab785646636"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga4f8eaf71cbc38948db216ab785646636">nytl::load</a> (std::istream &amp;is, T &amp;obj)</td></tr>
<tr class="memdesc:ga4f8eaf71cbc38948db216ab785646636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an object from an istream.  <a href="group__utility.html#ga4f8eaf71cbc38948db216ab785646636">More...</a><br /></td></tr>
<tr class="separator:ga4f8eaf71cbc38948db216ab785646636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac212f4de889ba7a6ae2a0664d1b83909"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac212f4de889ba7a6ae2a0664d1b83909"></a>
template&lt;typename T , typename Identifier , typename Base , typename... CArgs&gt; </td></tr>
<tr class="memitem:gac212f4de889ba7a6ae2a0664d1b83909"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nytl::addType</b> (Typemap&lt; Identifier, Base, CArgs... &gt; &amp;m, const Identifier &amp;id)</td></tr>
<tr class="separator:gac212f4de889ba7a6ae2a0664d1b83909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd99b9269cd611816a987386aff6d5c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacd99b9269cd611816a987386aff6d5c3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gacd99b9269cd611816a987386aff6d5c3">nytl::clone</a> (const T &amp;value)</td></tr>
<tr class="memdesc:gacd99b9269cd611816a987386aff6d5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the given (<a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>) object in a unique_ptr.  <a href="group__utility.html#gacd99b9269cd611816a987386aff6d5c3">More...</a><br /></td></tr>
<tr class="separator:gacd99b9269cd611816a987386aff6d5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf745403e740d4049bab038f3bae4bf87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf745403e740d4049bab038f3bae4bf87"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gaf745403e740d4049bab038f3bae4bf87">nytl::clone</a> (const T *value)</td></tr>
<tr class="memdesc:gaf745403e740d4049bab038f3bae4bf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the given (<a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>) object in a unique_ptr.  <a href="group__utility.html#gaf745403e740d4049bab038f3bae4bf87">More...</a><br /></td></tr>
<tr class="separator:gaf745403e740d4049bab038f3bae4bf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2d3a2a5b03293a43c7d80e8c86c3106"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab2d3a2a5b03293a43c7d80e8c86c3106"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gab2d3a2a5b03293a43c7d80e8c86c3106">nytl::clone</a> (const std::unique_ptr&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:gab2d3a2a5b03293a43c7d80e8c86c3106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the given (<a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>) object in a unique_ptr.  <a href="group__utility.html#gab2d3a2a5b03293a43c7d80e8c86c3106">More...</a><br /></td></tr>
<tr class="separator:gab2d3a2a5b03293a43c7d80e8c86c3106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>General utility base classes as well as smart pointers and helpers for serializing types. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga21ada50e83b7cfcab8133fdaf7c8e477"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utility.html#ga21ada50e83b7cfcab8133fdaf7c8e477">nytl::raw</a> = typedef typename detail::rawT&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Meta programming template to remove all qualifiers and references from a given type T. </p>

</div>
</div>
<a class="anchor" id="ga48a0a0b29a3d4cc37a7a285dc25e36af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utility.html#ga48a0a0b29a3d4cc37a7a285dc25e36af">nytl::void_t</a> = typedef void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++17 alias template for void, used to detect ill-formad types in a SFINAE-context. </p>
<p>If the compiler supports it, the std version will be used. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gacd99b9269cd611816a987386aff6d5c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; nytl::clone </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones the given (<a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>) object in a unique_ptr. </p>
<p>This function should always be called instead of <a class="el" href="group__utility.html#gab2d3a2a5b03293a43c7d80e8c86c3106" title="Clones the given (Cloneable) object in a unique_ptr. ">obj.clone()</a> since it is able to return a unique_ptr while still being able to have convarient return types in the member clone function. See <a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>, <a class="el" href="classnytl_1_1AbstractCloneable.html" title="Abstract Cloneable base class. ">AbstractCloneable</a> and derviveCloneable for more inforMation. </p>

</div>
</div>
<a class="anchor" id="gaf745403e740d4049bab038f3bae4bf87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; nytl::clone </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones the given (<a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>) object in a unique_ptr. </p>
<p>This function should always be called instead of <a class="el" href="group__utility.html#gab2d3a2a5b03293a43c7d80e8c86c3106" title="Clones the given (Cloneable) object in a unique_ptr. ">obj.clone()</a> since it is able to return a unique_ptr while still being able to have convarient return types in the member clone function. See <a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>, <a class="el" href="classnytl_1_1AbstractCloneable.html" title="Abstract Cloneable base class. ">AbstractCloneable</a> and derviveCloneable for more inforMation. </p>

</div>
</div>
<a class="anchor" id="gab2d3a2a5b03293a43c7d80e8c86c3106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; nytl::clone </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones the given (<a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>) object in a unique_ptr. </p>
<p>This function should always be called instead of <a class="el" href="group__utility.html#gab2d3a2a5b03293a43c7d80e8c86c3106" title="Clones the given (Cloneable) object in a unique_ptr. ">obj.clone()</a> since it is able to return a unique_ptr while still being able to have convarient return types in the member clone function. See <a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a>, <a class="el" href="classnytl_1_1AbstractCloneable.html" title="Abstract Cloneable base class. ">AbstractCloneable</a> and derviveCloneable for more inforMation. </p>

</div>
</div>
<a class="anchor" id="ga7db0db5ea24e292ebfa55613d95a45c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;decltype(clone(A{}))&gt; nytl::cloneVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>VectorObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to copy a Vector of <a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a> objects by cloning. </p>
<p>This can be useful if one has a Vector of polymorph objects which can not be copy constructed (e.g. Vector&lt;SomeAbstractBaseClass*&gt;), especially when dealing with smart pointers like std::unique_ptr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VectorObject</td><td>A Vector of <a class="el" href="classnytl_1_1Cloneable.html" title="Cloneable base class. ">Cloneable</a> objects (objects with a <a class="el" href="group__utility.html#gacd99b9269cd611816a987386aff6d5c3" title="Clones the given (Cloneable) object in a unique_ptr. ">clone()</a> member function). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of cloned objects. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4abfac9087e28a3a3ee48507fc28bfbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string nytl::dumpContainer </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;,\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps a given iteratable container to a stringstream and returns its content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>The sperator used after every container component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f8eaf71cbc38948db216ab785646636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nytl::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load an object from an istream. </p>
<p>If your type does neither overload the &gt;&gt; operator nor have a load member function, specialize this template function with your own type. </p>

</div>
</div>
<a class="anchor" id="ga3acfa7ed9dd857e72bb57096b541b15d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nytl::printVars </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the given args to the given output stream. </p>

</div>
</div>
<a class="anchor" id="gae9a79056e1d1df00484f0f6833856110"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nytl::unused </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility template function that can be used to hide unused compiler warnings. </p>
<p>Has usually no additional cost. Is meant as placeholder for future code. </p>

</div>
</div>
</div><!-- contents -->
		</div>
        <div id="footer-container">
            <div id="footer">
				nytl 0.1 Documentation, &copy; Jan Kelling 2015, published under <a href="https://github.com/nyorain/nytl/blob/master/LICENSE">MIT License</a><br />
				Documentation generated by <a href="http://www.stack.nl/~dimitri/doxygen/">doxygen</a>
            </div>
        </div>
    </body>
</html>
