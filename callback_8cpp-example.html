<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>nytl - Modern C++ template library</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="http://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="highlight.pack.js"></script>
		<link rel="stylesheet" type="text/css" href="obsidian.css">
		<script>
		$(document).ready(function() {
			hljs.configure({useBR: true});
			hljs.configure({tabReplace: '    '});
			$('.fragment').addClass("cpp");
			$('.fragment').each(function(i, block) {
				var $object1 = $(this);
				$(this).children(".line").each(function(i, block2) {
					$(this).find(".lineno").remove();
					$object1.append($(this).html());
					$object1.append("<br/>");
					$(this).remove();
				});
				hljs.highlightBlock(block);
			});
		});
		</script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <a href="index.html" id="nytl">nytl 0.1.0</a>
				<a href="http://www.github.com/nyorain/nytl" id="githublink">github</a>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">callback.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Simple example for the nytl::Callback class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="callback_8hpp.html">nytl/callback.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vec_8hpp.html">nytl/vec.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//Some dummy listener function</span></div><div class="line"><span class="keywordtype">void</span> someListenerFunction(<a class="code" href="namespacenytl.html#a21b7f2985d733acda4b365e6252e74fd">nytl::Vec2f</a> vec)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; vec &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">//Create a callback object with void(int, Vec2f) signature.</span></div><div class="line">    <span class="comment">//Note that this does NOT mean that all listeners (functions that are registered to be called</span></div><div class="line">    <span class="comment">//when the callback is triggered by Callback::call or by the call operator) must have the same </span></div><div class="line">    <span class="comment">//signature.</span></div><div class="line">    <span class="comment">//It does simply means they must have a compatible signature (see CompatibleFunction for</span></div><div class="line">    <span class="comment">//deeper information on that).</span></div><div class="line">    <span class="comment">//The return type of an callback listener must be convertible to void (so it can be any return</span></div><div class="line">    <span class="comment">//type) and the listener can take any of the 2 parameters, optionally.</span></div><div class="line">    <span class="comment">//Therefore listeners with signatures like int(int), char*(), void(nytl::Vec2f) or </span></div><div class="line">    <span class="comment">//std::string(int, nytl::Vec2f) are totally fine. The return type is not used anyways and the</span></div><div class="line">    <span class="comment">//not-needed parameters will simpley be ommitted.</span></div><div class="line">    <span class="comment">//On the other hand signatures like void(int, int) or char*(nytl::Vec2f, int) are NOT allowed.</span></div><div class="line">    <span class="comment">//The order of parameters can not be switched and there cannot be additional parameters.</span></div><div class="line">    nytl::Callback&lt;void(int, nytl::Vec2f)&gt; onEvent;</div><div class="line">    </div><div class="line">    <span class="comment">//Adds a callback listener in form of a lambda function</span></div><div class="line">    <span class="comment">//The returned object is a nytl::Connection, capable of observing the state of the callback and</span></div><div class="line">    <span class="comment">//listener as well as unregistering the listener (destroying the connection).</span></div><div class="line">    <span class="comment">//Note that Connection is just a proxy class around the real connection so it can be copied</span></div><div class="line">    <span class="comment">//and its destruction (i.e. going out of scope) has no effect. </span></div><div class="line">    <span class="comment">//If you want an RAII connection that disconnects itself automatically on destruction, see</span></div><div class="line">    <span class="comment">//nytl::RaiiConnection.</span></div><div class="line">    <span class="keyword">auto</span> connection = onEvent.add([]{ std::cout &lt;&lt; <span class="stringliteral">&quot;called\n&quot;</span>; }); </div><div class="line"></div><div class="line">    <span class="comment">//Output whether connection is connected, i.e the listener is still registered.</span></div><div class="line">    <span class="comment">//Will output true since the callback object still exists and the connection have not been</span></div><div class="line">    <span class="comment">//disconnected yet.</span></div><div class="line">    std::cout &lt;&lt; connection.connected() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">//Destroys the connection and therefore unregisters the lambda listener we added to the callback</span></div><div class="line">    <span class="comment">//above. Further calls to destroy() have no effect.</span></div><div class="line">    connection.destroy();</div><div class="line"></div><div class="line">    <span class="comment">//Will now output false</span></div><div class="line">    std::cout &lt;&lt; connection.connected() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//Callback does also overload the &quot;=&quot; and the &quot;+=&quot; operators.</span></div><div class="line">    <span class="comment">//+= adds a new callback listener. The operator does also return a connection object but since</span></div><div class="line">    <span class="comment">//the syntax for this would be a little weird (connection = callback += listener) one should</span></div><div class="line">    <span class="comment">//prefer to call Callback::add() if the returned connection is needed.</span></div><div class="line">    <span class="comment">//Does furhtermore exactly the same as an call to Callback::add().</span></div><div class="line">    onEvent += [](<span class="keywordtype">int</span> a) -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> a * 420; }; </div><div class="line"></div><div class="line">    <span class="comment">//= sets the callback listener. This does simply mean that it clears all existing ones and</span></div><div class="line">    <span class="comment">//sets the new listener as the ONLY one. In this case the above registered lambda listener</span></div><div class="line">    <span class="comment">//would be unregistered.</span></div><div class="line">    <span class="comment">//This effect can also be achieved with a call to Callback::clear which clears all existing </span></div><div class="line">    <span class="comment">//listeners and a following call to Callback::add which then sets one new listener.</span></div><div class="line">    onEvent = &amp;someListenerFunction; </div><div class="line"></div><div class="line">    <span class="comment">//The syntax is therefore a lot like html/javascript event callbacks (nytl::Callback has some</span></div><div class="line">    <span class="comment">//serious benefits, though) where you would also write something </span></div><div class="line">    <span class="comment">//like &quot;object.onEvent = function&quot; which would then set the given function as only listener.</span></div><div class="line">    </div><div class="line">    <span class="comment">//Finally calls/triggers the callback and all registered listenered with the given arguments.</span></div><div class="line">    <span class="comment">//In this case only the dummy someListenerFunction would be called.</span></div><div class="line">    onEvent.call(7, {23.f, 0.3f});</div><div class="line"></div><div class="line">    <span class="comment">//Calling can also be achieved directly with the call operator</span></div><div class="line">    onEvent(4, {12.f, 42.f});</div><div class="line"></div><div class="line">    <span class="comment">//There are many other (mostly more complex) things one can with a callback, such as retrieving</span></div><div class="line">    <span class="comment">//the returned values from all listeners when triggering the callback; disconnecting a listener</span></div><div class="line">    <span class="comment">//from inside its called function without the need to store a connection object or using</span></div><div class="line">    <span class="comment">//nytl::CompatibleFunction to e.g. add a callback to a member function of an object.</span></div><div class="line">    <span class="comment">//See the documentation of nytl::Callback, nytl::Connection, nytl::RaiiConnection, </span></div><div class="line">    <span class="comment">//nytl::ConnectionRef and nytl::CompatibleFunction for more information.</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
		</div>
        <div id="footer-container">
            <div id="footer">
				nytl 0.1 Documentation, &copy; Jan Kelling 2015, published under <a href="https://github.com/nyorain/nytl/blob/master/LICENSE">MIT License</a><br />
				Documentation generated by <a href="http://www.stack.nl/~dimitri/doxygen/">doxygen</a>
            </div>
        </div>
    </body>
</html>
